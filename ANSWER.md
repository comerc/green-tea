# Как устроен новый Green Tea GC?

> Интересно. Но жопой чую прям склонение к использованию каналов (гы). В код не посмотрел, но кажется, что все построено именно на каналах - это позволит более четко управлять памятью и процессорными потоками

Посмотрел исходники `go 1.25.5` в директории `go/src/runtime`.

Вынужден вас расстроить (или обрадовать): **каналов там нет вообще**. Ваше "жопой чую" в этот раз дало сбой, но ход мыслей про управление потоками был в верном направлении — просто реализация там гораздо более "хардкорная".

Вот как на самом деле устроен **Green Tea GC** (файл `mgcmark_greenteagc.go`):

1.  **Никаких `chan`**:
    Использование каналов в недрах GC было бы самоубийством по производительности из-за оверхеда на локи и переключения контекста. Вместо этого там используются **lock-free очереди** и атомики.

    - `localSpanQueue`: кольцевой буфер (ring buffer) на 256 элементов для каждого процессора (P).
    - `spanQueue`: глобальная очередь с мьютексом для балансировки нагрузки.

2.  **Главная идея — Локальность и Батчинг**:
    Обычный GC работает по принципу "нашел указатель -> добавил в стек -> пошел дальше" (LIFO). Это размазывает доступ по памяти.
    Green Tea GC работает иначе (FIFO + Batching):

    - Когда он находит указатель, он не сканирует объект сразу.
    - Он помечает "инлайн-биты" (`spanInlineMarkBits`) прямо в странице памяти (span), где лежит объект.
    - Спан (страница) целиком ставится в очередь (`spanQueue`).
    - Когда до спана доходит очередь, GC сканирует **все** накопленные объекты на этом спане разом. Это и есть та самая "векторизация" логическая — процессор молотит данные, которые лежат рядом, горячими кэш-линиями.

3.  **Work Stealing без каналов**:
    Вместо передачи сообщений через каналы, реализован механизм кражи работы (`spanQueueSteal`). Если у одного процессора (P) кончились спаны для сканирования, он лезет в локальные очереди соседей и "ворорует" пачку спанов через атомики (`CompareAndSwap`).

4.  **Странная арифметика**:
    В коде много битовой магии: `spanScanOwnership`, `or(spanScanOneMark)`, `atomic.Or8`. Это всё для того, чтобы несколько потоков могли параллельно помечать объекты на одной странице, не блокируя друг друга, а потом один "счастливчик" забирал страницу на сканирование.

**Итог:** Это не высокоуровневое управление через каналы, а низкоуровневая оптимизация доступа к памяти (Data Locality) и очередей задач, чтобы кормить процессор данными максимально плотно. Каналы бы тут только все замедлили.
